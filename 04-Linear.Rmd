```{r include=FALSE}
library(rethinking)
library(brms)
library(dplyr, quietly = TRUE)
library(tidyr, quietly = TRUE)
library(tidybayes, quietly = TRUE)
library(ggdist, quietly = TRUE)
library(patchwork, quietly = TRUE)
library(paletteer, quietly = TRUE)
```

# Linear Models {#linear}

## 4E1 {-}

See section 4.4.1

$y_i \sim \mathcal{N}(\mu, \sigma)$

## 4E2 {-}

2 parameters, $\mu$ and $\sigma$ which are in the posterior distribution
$y_i \sim \mathcal{N}(\mu, \sigma)$

## 4E3 {-}

See Overthinking in section 4.3.1

$$
\begin{align*}
P(\mu, \sigma \mid y) &=

\frac{
    P(y, \mu, \sigma)
}{
    P(y)
} \\

&= \frac{
    P(y, \mu, \sigma)
}{
    \int_{\sigma} \int_{\mu} P(y \mid \mu, \sigma) \cdot P(\mu, \sigma) d\mu d\sigma \\
} \\

&= 

\frac{
    \prod_i P(y_i, \mu, \sigma)
}{
    \int_{\sigma} \int_{\mu} \prod_i P(y_i \mid \mu, \sigma) \cdot P(\mu, \sigma) d\mu d\sigma \\
} \\

&=

\frac{
    \prod_i P(y_i \mid \mu, \sigma) \cdot P(\mu) \cdot P(\sigma)
}{
    \int_{\sigma} \int_{\mu} \prod_i P(y_i \mid \mu, \sigma) \cdot P(\mu) \cdot P(\sigma) d\mu d\sigma \\
} \\

&=

\frac{
    \prod_i \mathcal{N}(y_i \mid \mu, \sigma) \cdot \mathcal{N}(\mu \mid mean = 0, sd = 10) \cdot \mathcal{Exponential}(\sigma \mid rate = 1)
}{
    \int_{\sigma} \int_{\mu}{
        \prod_{i=1}^n \mathcal{N}(y_i \mid \mu, \sigma) \cdot \mathcal{N}(\mu \mid mean = 0, sd = 10) \cdot \mathcal{Exponential}(\sigma \mid rate = 1)
    }
    d\mu d\sigma
}

\end{align*}
$$


## 4E4 {-}

$\mu_i = \alpha + \beta x_i$

## 4E5 {-}



2 parameters, $\mu$ and $\sigma$

## 4M1 {-}

See R code 4.13 in section 4.3.2 using this model

```{r}
# simulate the heights using the prior, not the posterior
set.seed(4)  # set the seed as random sample can vary and give error later
n_samples <- 1e4
sample_mu <- rnorm(n = n_samples, mean = 0, sd = 10)
sample_sigma <- rexp(n = n_samples, rate = 1)
prior_h <- rnorm(n = n_samples, mean = sample_mu, sd = sample_sigma)
```

```{r}
# plot the density of heights using the priors
prior_h <- data.frame(height = prior_h)
ggplot(data = prior_h, mapping = aes(x = height)) +
    geom_density(aes(y = ..scaled..), color = "brown1", size = 1) +
    theme_minimal() +
    labs(title = "4M1: distribution of heights using priors")
```

## 4M2 {-}

### with `quap` {-}

See section 4.4.2 on how to use `quap`, R code 4.43 with linear equation with
the `quap` formula, i.e. `flist`


```{r eval=FALSE}
alist(
    height ~ dnorm(mean = mu, sd = sigma),
    mu = a + b * x,
    a ~ dnorm(mean = 0, sd = 10),
    b ~ dnorm(mean = 0, sd = 1),
    sigma ~ dexp(rate = 1)
    )
```

### with `brm` {-}

See section 4.4.2

In `brms` the formula is shown separately than the priors as follows

```{r eval=FALSE, error=FALSE}
# brms::brm(data,
#           formula = height ~ 1 + x,
#           family = gaussian(),
#           prior = c(prior(normal(0, 10), class = Intercept),
#                     prior(normal(0, 1), class = b),
#                     prior(exponential(1), class = sigma)),
#             iter = 2000, warmup = 1000, chains = 4, cores = detectCores(),
#             seed = 4)
```


## 4M3 {-}

Make sure you remember to index the $y$ so that it is $y_i$ as well as $\mu$.
See section 4.4.2.  The published answer does not put an index on $\mu$ but it
has one on $\y$ which involves a constant $\mu$ which is normaly the intercept!
This question is confusing, here we assume the same meaning as in section 4.4.2.,
that is $\mu$ varies

$$
\begin{align*}
y_i &\sim \mathcal{N}(mean = \mu, sd = \sigma)\\
\mu &= \alpha + \beta \cdot x_i \\
\alpha &\sim \mathcal{N}(mean = 0, sd = 10) \\
\beta &\sim \mathcal{Uniform}(mean = 0, sd = 1) \\
\sigma &\sim \mathcal{Exponential}(\lambda = 1)
\end{align*}
$$

## 4M4 {-}

Don't forget the index so that $height$ is $height_i$.

This will be giving the average height per year.  The question is not clear
that it wants it by student also.

$$
\begin{align*}
height_i &\sim \mathcal{N}(\mu_i, \sigma) \\
\mu_i &= \alpha + \beta \cdot year_i \\
\alpha &\sim \mathcal{N}(100, 10) \\
\beta &\sim \mathcal{Uniform}(0, 10) \\
\sigma &\sim \mathcal{Exponential}(1)
\end{align*}
$$

## 4M5 {-}

This tells us that $\beta$ should always be positive be with large values unlikely.
We therefore use the log-normal dist as a prior for $\beta$. See section 4.4.2.

$$
\begin{align*}
height_i &\sim Normal(\mu_i, \sigma) \\
\mu_i &= \alpha + \beta \cdot year_i \\
\alpha &\sim \mathcal{Normal}(100, 10) \\
\beta &\sim \mathcal{LogNormal}(0, 1) \\
\sigma &\sim \mathcal{Exponential}(1)
\end{align*}
$$

## 4M6 {-}

Instead of using the average range as a prior for $\sigma$ we would use
$\sigma = \sqrt{64} = 8$.

> In the official solution solution McElreath says it should be 
$\sigma \sim Uniform(0, 64)$, no sqrt of the *variance* to obtain the
*standard deviation* is done.

$$
height_i \sim Normal(\mu_i, \sigma) \\
mu_i = \alpha + \beta \cdot year_i \\
\alpha \sim Normal(120, 10) \\
\beta \sim Normal(0, 10) \\
\sigma \sim Uniform(0, 8)
$$

## 4M7 {-}

See section4.4.2 (at the beginning) for model m4.3.

```{r}
data(Howell1)
d <- Howell1 %>%
  filter(age  >= 18) %>%
  mutate(weight_c = scale(weight, center = TRUE, scale = FALSE))
skimr::skim(d)
```

### Using `quap`

The fit using the centered

```{r}
a_file <- here::here("fits", "m04M7_center.rds")  # rds file location
m04M7_center <- readRDS(file = a_file)
# m04M7_center <- quap(
#   flist = alist(
#     height ~ dnorm(mu, sigma),
#     mu <- a + b * weight_c,
#     a ~ dnorm(178, 20),
#     b ~ dlnorm(0, 1),
#     sigma ~ dunif(0, 50)
#   ),
#   data = d,
#   start = list(a = mean(d$weight), b = 0.5)
# )
# saveRDS(object = m04M7_center, file = a_file)
```


The fit using the predictor on the natural scale


```{r}
a_file <- here::here("fits", "m04M7_natural.rds")  # rds file location
m04M7_natural <- readRDS(file = a_file)
# m04M7_natural <- quap(
#   flist = alist(
#     height ~ dnorm(mu, sigma),
#     mu <- a + b * (weight),
#     a ~ dnorm(178, 20),
#     b ~ dlnorm(0, 1),
#     sigma ~ dunif(0, 50)
#   ),
#   data = d,
#   start = list(a = mean(d$weight), b = 0.5)
# )
# saveRDS(object = m04M7_natural, file = a_file)
```

and comparing the 2 results.  The parameter `corr = TRUE` does not seem to work
in `precis` so we use the var-cov matrix and convert it to correlations.

```{r}
precis(m04M7_center, corr = TRUE, digits = 1)
round(cov2cor(vcov(m04M7_center)), 4)
```


```{r}
precis(m04M7_natural, corr = TRUE, digits = 1)
round(cov2cor(vcov(m04M7_natural)), 4)
```

Conclusion: The intercept and sigma are the same but the `a` coefficients
are different and the correlations are strong on the natural scale and
non-existent on the centered scale.  This is an effect that is well documented with
the correlation coefficient when distant data points from the origin are used.


### Using `brm`

```{r}
a_file <- here::here("fits", "b04M7_center.rds")  # rds file location
# load fit from file saved before
b04M7_center <- readRDS(file = a_file)
# fit model and save to file
# b04M7_center <- brms::brm(
#   data = d,
#   family = gaussian,
#   formula = height ~ 1 + weight_c,
#   prior = c(
#     prior(normal(178, 20), class = Intercept),
#     prior(lognormal(0, 1), class = b, lb = 0, ub = 3),
#     prior(exponential(1), class = sigma)),
#   iter = 2000, warmup = 1000, chains = 4, cores = detectCores(),  seed = 4)
# saveRDS(b04M7_center, file = a_file)
```

```{r}
summary(b04M7_center)
```


```{r}
a_file <- here::here("fits", "b04M7_natural.rds")
# load fit from file saved before
b04M7_natural <- readRDS(file = a_file)
# fit model and save to file
# b04M7_natural <- brms::brm(
#   data = d,
#   family = gaussian,
#   formula = height ~ 1 + weight,
#   prior = c(
#     prior(normal(178, 20), class = Intercept),
#     prior(lognormal(0, 1), class = b, lb = 0, ub = 3),
#     prior(exponential(1), class = sigma)),
#   iter = 2000, warmup = 1000, chains = 4, cores = detectCores(), seed = 4)
# saveRDS(b04M7_natural, file = a_file)
summary(b04M7_natural)
```

and to calculate the correlations and visualize we sample the posterior


```{r}
b04M7_center_post <- posterior_samples(b04M7_center)
b04M7_natural_post <- posterior_samples(b04M7_natural)
```

which gives the following correlations

```{r}
b04M7_center_post %>%
  select(-lp__) %>%
  cor() %>%
  round(digits=2)
```


```{r}
b04M7_natural_post %>%
  select(-lp__) %>%
  cor() %>%
  round(digits=2)
```
and again with the same results as when using `quap`.

and we visualize the predictions using the 2 models we use the following wequnce of weights

```{r}
weight_seq <- as.integer(range(d$weight))
weight_seq <- seq(from = floor(min(d$weight)), to = ceiling(max(d$weight)), by = 1)
weight_seq <- tibble(weight = weight_seq) %>%
  mutate(weight_c = as.vector(scale(weight, center = TRUE, scale = FALSE)))
```



```{r}
b04M7_center_pred <- predict(b04M7_center, newdata = weight_seq) %>%
  data.frame() %>%
  bind_cols(weight_seq)
# glimpse(b04M7_center_pred)
```

```{r}
b04M7_natural_pred <- predict(b04M7_natural, newdata = weight_seq) %>%
  data.frame() %>%
  bind_cols(weight_seq)
```

and we illustrate the 2 predictions

```{r}
p1 <- ggplot(d, aes(x = weight, y = height, color = age)) +
  geom_smooth(data = b04M7_center_pred,
              aes(y = Estimate, ymin = Q2.5, ymax = Q97.5), stat = "identity",
              fill = "aquamarine", color = "aquamarine4", alpha = 1, size = 1) +
  geom_point() +
  scale_color_paletteer_c(palette = "pals::kovesi.linear_bgyw_15_100_c67") +
  theme_minimal() +
  theme(legend.position = c(0.8, 0.25))
  
# p1
```


```{r}
p2 <- ggplot(d, aes(x = weight, y = height, color = age)) +
  geom_smooth(data = b04M7_natural_pred,
              aes(y = Estimate, ymin = Q2.5, ymax = Q97.5), stat = "identity",
              fill = "wheat", color = "wheat4", alpha = 1, size = 1) +
  geom_point() +
  scale_color_paletteer_c(palette = "pals::kovesi.linear_bgyw_15_100_c67") +
  theme_minimal() +
  theme(legend.position = c(0.8, 0.25))
  
# p2
```


```{r}
p1 + p2
```



## 4M8 {-}

Not done

## 4H1 {-}

We first create the dataframes in many of the following practices.

```{r}
data("Howell1")
d <- Howell1
d1 <- d %>%
  filter(age < 18) %>%
  mutate(weight_c = scale(weight, center = TRUE, scale = FALSE))
d2 <- d %>%
  filter(age >= 18) %>%
  mutate(weight_c = scale(weight, center = TRUE, scale = FALSE))
stopifnot(nrow(d) == sum(nrow(d1) + nrow(d2)))
attributes(d1$weight_c)
m04H1_weight_c <- attr(d1$weight_c, which = "scaled:center")
```

and the model that will be used


$$
\begin{align*}
height_i &\sim \mathcal{N}(\mu_i, \sigma) \\
\mu_i &= \alpha + \beta \cdot weight_i \\
\alpha &\sim \mathcal{N}(178, 20) \\
\beta &\sim \mathcal{LogNormal}(0, 1) \\
\sigma &\sim \mathcal{Exponential}(1)
\end{align*}
$$

and we verify the result with `quap`


```{r}
a_file <- here::here("fits", "m04H1.rds")
m04H1 <- readRDS(file = a_file)
m04H1 <- quap(
  flist = alist(
    height ~ dnorm(mu, sigma),
    mu <- a + b * weight,
    a ~ dnorm(0, 1000),
    b ~ dlnorm(0, 1),
    sigma ~ dexp(1)
  ),
  data = d2,
  start = list(a = mean(d2$weight), b = 0.5)
)
saveRDS(object = m04H1, file = a_file)
```

```{r}
vcov(m04H1)
# matrixcalc::is.positive.definite(vcov(m04H1), tol = 1e-4)
```


get the posterior

```{r}
# the center used when centering was done, this is a constant
m04H1_post <- extract.samples(m04H1)
m04H1_pred <- rnorm(n = nrow(m04H1_post), 
                   mean = m04H1_post$a + m04H1_post$b * 46.95,
                   sd = m04H1_post$sigma)
ggdist::mean_hdi(m04H1_pred, .width = 0.89)
```

and find the predictions using the detailed method as described
in overthinking box of section 4.4.3.4. The `rethinking::link()` function
does that.

```{r}
the_weights <- c(46.95, 43.72, 64.78, 32.59, 54.63)
the_preds <- t(sapply(X = the_weights, FUN = function(x) {
  y <- rnorm(n = nrow(m04H1_post), 
             mean = m04H1_post$a + m04H1_post$b * x,
             sd = m04H1_post$sigma)
  ggdist::mean_hdi(y, .width = 0.89)
}))
# the_preds
```



## 4H2 {-}

Load the data

```{r}
# there should be 192 rows
stopifnot(nrow(d1) == 192)
```

The model used is

$$
height_i \sim \mathcal{N}(\mu_i, \sigma) \\
\mu_i = \alpha + \beta \cdot weight_i \\
\alpha \sim \mathcal{N}(178 / 2, 20 / 2) \\
\beta \sim \mathcal{LogNormal}(0, 1) \\
\sigma \sim \mathcal{Cauchy}(0, 1)
$$
### 4H2 a) with `quap` {-}

> Important: Using sigma ~ dexp(rate = 1) create non semi.definite positive
matrix.  Using sigma ~ dcauchy(location = 0, scale = 1) always work.


```{r}
a_file <- here::here("fits", "m04H2.rds")
m04H2 <- readRDS(file = a_file)
# m04H2 <- rethinking::map(
#     flist = alist(
#         height ~ dnorm(mu, sigma),
#         mu <- a + b * weight,
#         a ~ dnorm(178 / 2, 100 / 2),
#         b ~ dlnorm(0, 1),
#         sigma ~ dcauchy(location = 0, scale = 1)
#         ),
#     data = d1
# )
# saveRDS(m04H2, file = a_file)
m04H2_summ <- rethinking::precis(m04H2, prob = 0.89)
m04H2_summ
```

for 10 more units of weights the child should be taller between 26 and 28 cm

### 4H2 b) with `quad` {-}

#### Get the fitted values with `quad` {-}

See section 4.4.3.4 for more details.

```{r}
weight_seq <- round(range(d1$weight), 0)
weight_seq <- seq(from = weight_seq[1], to = weight_seq[2], by  = 1)
weight_seq <- data.frame(weight = weight_seq)
```

```{r}
precis(m04H2)
# m04H2_post <- extract.samples(m04H2)
```

See the overthinking box in section 4.4.3.4 to explain `rethinking::link()`

```{r}
m04H2_fitted <- rethinking::link(fit = m04H2, 
                                 data = weight_seq, 
                                 n = 1000)
# str(m04H2_fitted)
m04H2_fitted_inrvl <- apply(X = m04H2_fitted, MARGIN = 2, FUN = function(x) {
  c("mean" = mean(x), rethinking::HPDI(x))
}) %>%
  t() %>%
  bind_cols(weight = weight_seq) %>%
  as.data.frame()
# m04H2_fitted_inrvl
```
and the prediction intervals are obtained as described in section 4.4.3.5
using `rethinking::sim()`

```{r}
m04H2_predict <- rethinking::sim(fit = m04H2,
                                 data = data.frame(weight = weight_seq),
                                 n = 1000)
m04H2_predict_inrvl <- apply(X = m04H2_predict, MARGIN = 2, FUN = function(x) {
  c("mean" = mean(x), rethinking::HPDI(x))
}) %>% 
  t() %>%
  bind_cols(weight = weight_seq) %>%
  as.data.frame()
# m04H2_predict_inrvl
```




```{r}
ggplot(data = d1, aes(x = weight)) +
  geom_ribbon(data = m04H2_predict_inrvl,
              aes(ymin = `|0.89`, ymax = `0.89|`),
              fill = "lightcyan") +
  geom_smooth(data = m04H2_fitted_inrvl,
              aes(y = mean, ymin = `|0.89`, ymax = `0.89|`),
              stat = "identity",
              fill = "lightcyan3", color = "black", alpha = 1, size = 1/2) +
  geom_point(aes(y = height, color = age), shape = 20, size = 2, alpha = 2/3) +
  scale_x_continuous( breaks = scales::breaks_extended(n = 7)) +
  scale_color_paletteer_c("pals::kovesi.linear_kryw_5_100_c67") +
  coord_cartesian(xlim = range(d1$weight), ylim = range(d1$height)) +
  theme_minimal() +
  theme(title = element_text(color = "midnightblue"),
        legend.position = c(0.1, 0.8)) +
  labs(title = "quap fit - Practice 4H2", x = "weight", y = "height")
```


### 4H2 a) with `brm` {-}

Same comments and conclusion as for `quap` above

```{r}
a_file <- here::here("fits", "b04H2.rds")  # save to rds file
b04H2 <- readRDS(file = a_file)
# b04H2 <- brms::brm(data = d1,
#                          formula = height ~ 1 + weight,
#                          family = gaussian(),
#                          prior = c(
#                            prior(normal(178 / 2, 20 / 2), class = Intercept),
#                            prior(lognormal(0, 1), class = b),
#                            prior(cauchy(0, 1), class = sigma)),
#                          iter = 2000, warmup = 1000, chains = 4,
#                          cores = detectCores(), seed = 4)
# saveRDS(b04H2, file = a_file)
b04H2_fixf <- brms::fixef(b04H2)
b04H2_fixf
```

### 4H2 b) with `brm` {-}


```{r}
weight_seq <- round(range(d1$weight), 0)
weight_seq <- seq(from = weight_seq[1], to = weight_seq[2], by  = 1)
weight_seq <- data.frame(weight = weight_seq)
```


```{r}
b04H2_fitted <-
  fitted(b04H2, newdata = weight_seq, probs = c(0.055, 0.945)) %>%
  data.frame() %>%
  bind_cols(weight_seq)
# glimpse(b04H2_fitted)

b04H2_predict <-
  predict(b04H2, newdata = weight_seq, probs = c(0.055, 0.945)) %>%
  data.frame() %>%
  bind_cols(weight_seq)
# glimpse(b04H2_predict)
```


and we illustrate the results


```{r}
ggplot(data = d1, aes(x = weight)) +
  geom_ribbon(data = b04H2_predict,
              aes(ymin = Q5.5, ymax = Q94.5),
              fill = "lightcyan") +
  geom_smooth(data = b04H2_fitted,
              aes(y = Estimate, ymin = Q5.5, ymax = Q94.5),
              stat = "identity",
              fill = "lightcyan3", color = "black", alpha = 1, size = 1/2) +
  geom_point(aes(y = height, color = age), shape = 20, size = 2, alpha = 2/3) +
  scale_x_continuous( breaks = scales::breaks_extended(n = 7)) +
  scale_color_paletteer_c("pals::kovesi.linear_kryw_5_100_c67") +
  coord_cartesian(xlim = range(d1$weight), ylim = range(d1$height)) +
  theme_minimal() +
  theme(title = element_text(color = "midnightblue"),
        legend.position = c(0.1, 0.8)) +
  labs(title = "BRMS fit - Practice 4H2", x = "weight", y = "height")
```



### 4H2 c) {-}

The data points seem to have a nonlinear relation with weight.


## 4H3 {-}

This is covered by section 4.5.1 polynomial regression but instead of polynomial
we use a log equation.

The model used is

$$
height_i \sim \mathcal{N}(\mu_i, \sigma) \\
\mu_i = \alpha + \log{(\beta)} \cdot weight_i \\
\alpha \sim \mathcal{N}(178, 20) \\
\beta \sim \mathcal{N}(0, 10) \\
\sigma \sim \mathcal{Cauchy}(0, 1)
$$

### 4H3 a) using `quap` {-}

> Important: We have to use `dunif` for sigma to make the `quap` converge. Otherwise
the cov matrix is not positive definite.

```{r}
a_file <- here::here("fits", "m04H3.rds")  # save to rds file
m04H3 <- readRDS(file = a_file)
# m04H3 <- rethinking::quap(
#     flist = alist(
#         height ~ dnorm(mu, sigma),
#         mu <- a + b * log(weight),
#         a ~ dnorm(178, 20),
#         b ~ dnorm(0, 10),
#         sigma ~ dunif(0, 50)
#         ),
#     data = d
# )
# saveRDS(m04H3, file = a_file)
rethinking::precis(m04H3, prob = 0.89)
```

Since we use $\log{weight}$ than any change of $\log{weight}$ represents
a percentage change of $weight$, therefore $b$ represents that, for every
percentage increase of the weight, the height is reduced by -2.65 of a percentage.


### 4H3 b) using `quap` {-}

We use the same process as in 4H2 just above

```{r}
weight_seq <- round(range(d$weight), 0)
weight_seq <- seq(from = weight_seq[1], to = weight_seq[2], by  = 1)
weight_seq <- data.frame(weight = weight_seq)
```

same process as in 4H2 above

```{r}
m04H3_fitted <- rethinking::link(fit = m04H3, 
                                 data = weight_seq, 
                                 n = 1000)
# str(m04H3_fitted)
m04H3_fitted_inrvl <- apply(X = m04H3_fitted, MARGIN = 2, FUN = function(x) {
  c("mean" = mean(x), rethinking::HPDI(x, prob = 0.97))
}) %>%
  t() %>%
  bind_cols(weight = weight_seq) %>%
  as.data.frame()
# m04H3_fitted_inrvl
```
and the prediction intervals are obtained as described in section 4.4.3.5
using `rethinking::sim()` (sames as in 4H2 above)

```{r}
m04H3_predict <- rethinking::sim(fit = m04H3,
                                 data = data.frame(weight = weight_seq),
                                 n = 1000)
m04H3_predict_inrvl <- apply(X = m04H3_predict, MARGIN = 2, FUN = function(x) {
  c("mean" = mean(x), rethinking::HPDI(x, prob = 0.97))
}) %>% 
  t() %>%
  bind_cols(weight = weight_seq) %>%
  as.data.frame()
# m04H3_predict_inrvl
```




```{r}
ggplot(data = d, aes(x = weight)) +
  geom_ribbon(data = m04H3_predict_inrvl,
              aes(ymin = `|0.97`, ymax = `0.97|`),
              fill = "aquamarine1") +
  geom_smooth(data = m04H3_fitted_inrvl,
              aes(y = mean, ymin = `|0.97`, ymax = `0.97|`),
              stat = "identity",
              fill = "aquamarine4", color = "black", alpha = 1, size = 1/2) +
  geom_point(aes(y = height, color = age), shape = 20, size = 2, alpha = 2/3) +
  scale_x_continuous( breaks = scales::breaks_extended(n = 7)) +
  scale_color_paletteer_c("pals::kovesi.linear_kry_5_98_c75") +
  coord_cartesian(xlim = range(d$weight), ylim = range(d$height)) +
  theme_minimal() +
  theme(title = element_text(color = "midnightblue"),
        legend.position = c(0.1, 0.8)) +
  labs(title = "quap fit - Practice 4H3", x = "weight", y = "height")
```


### 4H3 a) using `brm` {-}


Same comments and conclusion as for `quap` above. The results are very similar.

```{r}
a_file <- here::here("fits", "b04H3.rds")  # save to rds file
b04H3 <- readRDS(file = a_file)
# b04H3 <- brms::brm(data = d,
#                    formula = height ~ 1 + log(weight),
#                    family = gaussian(),
#                    prior = 
#                      c(prior(normal(178, 20), class = Intercept),
#                        prior(normal(0, 10), class = b),
#                        prior(cauchy(0, 1), class = sigma)),
#                    iter = 2000, warmup = 1000, chains = 4,
#                    cores = detectCores(), seed = 4)
# saveRDS(b04H3, file = a_file)
b04H3_fixf <- brms::fixef(b04H3)
b04H3_fixf
```

### 4H3 b) using `brm` {-}


```{r}
weight_seq <- round(range(d$weight), 0)
weight_seq <- seq(from = weight_seq[1], to = weight_seq[2], by  = 1)
weight_seq <- data.frame(weight = weight_seq)
```


```{r}
b04H3_fitted <-
  fitted(b04H3, newdata = weight_seq, probs = c(0.015, 0.985)) %>%
  data.frame() %>%
  bind_cols(weight_seq)
# glimpse(b04H3_fitted)

b04H3_predict <-
  predict(b04H3, newdata = weight_seq, probs = c(0.015, 0.985)) %>%
  data.frame() %>%
  bind_cols(weight_seq)
# glimpse(b04H3_predict)
```


and we illustrate the results


```{r}
ggplot(data = d, aes(x = weight)) +
  geom_ribbon(data = b04H3_predict,
              aes(ymin = Q1.5, ymax = Q98.5),
              fill = "aquamarine1") +
  geom_smooth(data = b04H3_fitted,
              aes(y = Estimate, ymin = Q1.5, ymax = Q98.5),
              stat = "identity",
              fill = "aquamarine4", color = "black", alpha = 1, size = 1/2) +
  geom_point(aes(y = height, color = age), shape = 20, size = 2, alpha = 2/3) +
  scale_x_continuous( breaks = scales::breaks_extended(n = 7)) +
  scale_color_paletteer_c("pals::kovesi.linear_kry_5_98_c75") +
  coord_cartesian(xlim = range(d$weight), ylim = range(d$height)) +
  theme_minimal() +
  theme(title = element_text(color = "midnightblue"),
        legend.position = c(0.1, 0.8)) +
  labs(title = "BRMS fit - Practice 4H3", x = "weight", y = "height")
```

## 4H4 {-}

See section 4.5.1  for reference to this practice. R code 4.65 (p. 111)

The data is as in section 4.5.1.  This practice is using techniques that
are illustrated at the beginning of section 5.1 in the next chapter.

```{r}
data("Howell1")
df04H4 <- Howell1 %>%
  mutate(weight_c = scale(weight, center = TRUE, scale = FALSE),
         weight_c2 = weight_c ^ 2)
skimr::skim(df04H4)
```


the model has been slightly modified by using the centered weight instead of
the standard weight.  It seems to work better with `quap`.

The values for $a$ are from the summary using `skimr` just above.


$$
\begin{align*}
h_i &\sim \mathcal{N}(\mu_i, \sigma)\\
\mu_i &= \alpha + \beta_1 \cdot weight\_c_i + \beta_2 \cdot weight\_c^2_i \\
\alpha &\sim \mathcal{N}(138, 50) \\
\beta_1 &\sim \mathcal{LogNormal}(0,1) \\
\beta_2 &\sim \mathcal{N}(0,1) \\
\sigma &\sim \mathcal{Cauchy}(0, 1)
\end{align*}
$$

### 4H4 using `quap` {-}




```{r}
a_file <- here::here("fits", "m04H4.rds")  # save to rds file
m04H4 <- readRDS(file = a_file)
# m04H4 <- quap(
#   flist = alist(
#     height ~ dnorm(mu, sigma),
#     mu <- a + b1 * weight_c + b2 * weight_c2,
#     a ~ dnorm(138, 50),
#     b1 ~ dlnorm(0, 1),
#     b2 ~ dnorm(0, 1),
#     sigma ~ dunif(0, 50)
#   ),
#   data = df04H4
# )
# saveRDS(m04H4, file = a_file)
rethinking::precis(m04H4)
```
The function `rethinking::extract.prior()` is used to extract the sample distributions
from the fit.  Then the process of finding the mus is the same as the overthinking box
of section 4.4.3.4 (p.107).  Or in other words, using the `link` function with
the prios used in the `post` argument
.

```{r}
m04H4_prior <- extract.prior(m04H4, n = 1000) %>%
  as.data.frame()
# str(m04H4_prior)
stopifnot(all(m04H4_prior$sigma > 0))
```

and find the predictions using the detailed method as described
in overthinking box of section 4.4.3.4. The `rethinking::link()` function
does that. For an example, see at the beginning of section 5.1 in the next chapter, 
R code 5.4.

For this exercise, we will do it the long way.

```{r}
weight_seq <- round(range(df04H4$weight_c), 0)
weight_seq <- seq(from = weight_seq[1], to = weight_seq[2], 
                  by = 1)
weight_seq <- data.frame(weight_c = weight_seq)
# str(weight_seq)
```


```{r}
the_prior_preds <- lapply(X = weight_seq$weight_c, FUN = function(x) {
  mu <- m04H4_prior$a + m04H4_prior$b1 * x + m04H4_prior$b2 * x^2
  y <- rnorm(n = length(mu),
             mean = mu,
             sd = m04H4_prior$sigma)
  ggdist::mean_hdi(y, .width = 0.89)
})
the_prior_preds <- do.call(rbind, the_prior_preds) %>%
  bind_cols(weight_seq) %>%
  as.data.frame()
# str(the_prior_preds)
```


```{r}
ggplot(data = df04H4, aes(x = weight_c)) +
  geom_line(data = the_prior_preds, aes(y = y), size = 1, color = "purple") +
  geom_point(aes(y = height, color = age), shape = 20, size = 2, alpha = 2/3) +
  scale_x_continuous( breaks = scales::breaks_extended(n = 7)) +
  scale_color_paletteer_c("pals::kovesi.rainbow_bgyrm_35_85_c71") +
  theme_minimal() +
  theme(title = element_text(color = "midnightblue"),
        legend.position = c(0.85, 0.30)) +
  labs(title = "quap fit with PRIOR - Practice 4H4", x = "weight", y = "height")
```

which shows that the prior is not so bad, it's shape aligns with the data, only
the intercept actually need to be modified.

> Conclusion: It's a very good idea to simulate the priors.  It tells us
if they make sense.  It helps greatly in having a converging fit.


### 4H4 using `brm` {-}

**Note the use of `sample_prior = TRUE`** to be able to obtain the prior
samples.  We use the prior $b1 \sim \mathcla{N}(0,1)$ instead of $\mathcal{LogNormal}$
which gives a much better prior in this case.

```{r}
a_file <- here::here("fits", "b04H4.rds")  # save to rds file
b04H4 <- readRDS(file = a_file)
# b04H4 <- brms::brm(data = df04H4,
#                    formula = height ~ 1 + weight_c + weight_c2,
#                    family = gaussian,
#                    prior =
#                      c(prior(normal(138, 50), class = Intercept),
#                        prior(normal(0, 1), class = b, coef = "weight_c"),
#                        prior(normal(0, 1), class = b, coef = "weight_c2"),
#                        prior(cauchy(0, 1), class = sigma)),
#                    iter = 2000, warmup = 1000, chains = 4,
#                    sample_prior = TRUE,
#                    cores = detectCores(), seed = 4)
# saveRDS(b04H4, file = a_file)
brms::fixef(b04H4)
```

create the sequence of weights to use

```{r}
weight_seq <- round(range(df04H4$weight_c), 0)
weight_seq <- seq(from = weight_seq[1], to = weight_seq[2], length.outt = 30)
weight_seq <- data.frame(weight_c = weight_seq) %>%
  mutate(weight_c2 = weight_c^2)
# glimpse(weight_seq)
```

sample the prior and create the fit

```{r}
b04H4_prior <- brms::prior_samples(b04H4)
b04H4_prior_fit <- b04H4_prior %>%
  slice_sample(n = 100) %>%
  tibble::rownames_to_column("draw") %>%
  expand(nesting(draw, Intercept, b_weight_c, b_weight_c2),
                 x = weight_seq$weight_c, x2 = weight_seq$weight_c2) %>%
  mutate(height_fit = Intercept + b_weight_c * x + b_weight_c2 * x2)
glimpse(b04H4_prior_fit)
b04H4_prior_fit_interval <- b04H4_prior_fit %>%
  group_by(x) %>%
  do(ggdist::mean_hdi(.$height_fit, .width = 0.89)) %>%
  rename("mu" = x, "height" = y)
glimpse(b04H4_prior_fit_interval)
```


get the posterior fit($\mu$) and prediction  ($\hat{y}$)

```{r}
b04H4_fitted <-
  fitted(b04H4, newdata = weight_seq, probs = c(0.055, 0.945)) %>%
  data.frame() %>%
  bind_cols(weight_seq)
# glimpse(b04H4_fitted)

b04H4_predict <-
  predict(b04H4, newdata = weight_seq, probs = c(0.055, 0.945)) %>%
  data.frame() %>%
  bind_cols(weight_seq)
# glimpse(b04H4_predict)
```


visualize the prior and posterior

```{r}
ggplot(df04H4, aes(x = weight_c)) +
  geom_ribbon(data = b04H4_predict,
              aes(ymin = Q5.5, ymax = Q94.5),
              fill = "slategray1") +
  geom_smooth(data = b04H4_fitted,
              aes(y = Estimate, ymin = Q5.5, ymax = Q94.5),
              stat = "identity",
              fill = "slategray4", color = "black", alpha = 1, size = 1/2) +
  geom_line(data = b04H4_prior_pred_interval, aes(y = height), 
            size = 1, color = "purple") +
  geom_point(aes(y = height, color = age), shape = 20, size = 2, alpha = 2/3) +
    theme_minimal() +
  scale_x_continuous(breaks = scales::breaks_extended(n = 7)) +
  scale_color_paletteer_c("pals::kovesi.rainbow_bgyrm_35_85_c71") +
  coord_cartesian(xlim = range(weight_seq$weight_c)) +
  theme(title = element_text(color = "midnightblue"),
        legend.position = c(0.80, 0.30)) +
  labs(title = "BRMS fit with PRIOR - Practice 4H4", x = "weight", y = "height")
```
